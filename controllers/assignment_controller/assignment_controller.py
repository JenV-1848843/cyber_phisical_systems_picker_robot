# === SLAM Controller for Webots ===

# ──────────────────────────────────────────────────────────────
# IMPORTS
# ──────────────────────────────────────────────────────────────
from controller import Robot
import numpy as np
import math
import threading
import time
from itertools import islice
import concurrent.futures
import queue

# Config
from config import MAP_SIZE_X, MAP_SIZE_Y, TIME_STEP, UNKNOWN, OBSTACLE, backup_map

# Custom modules
from SLAM.mapping import inflate_obstacles, update_map, world_to_map, map_to_world, get_corridor_id
from SLAM.navigation import drive_to_target, astar
from SLAM.odometry import update_odometry
from task_queue.taskqueuecontroller import on_task_received, start_async_task_queue_listener, print_task_on_task_received
from frontiers import find_frontier
from utils import plot_map, create_status_update
from communication.rest import initiate_robot
from communication.sockets import connect_to_server, corridor_update_callback, send_corridor_update, send_status_update, send_map_update, send_map_data, register_map_update_callback

# ──────────────────────────────────────────────────────────────
# ROBOT INITIALIZATION
# ──────────────────────────────────────────────────────────────
robot = Robot()
left_motor = robot.getDevice("left wheel motor")
right_motor = robot.getDevice("right wheel motor")
left_sensor = robot.getDevice("left wheel sensor")
right_sensor = robot.getDevice("right wheel sensor")
lidar = robot.getDevice("LDS-01")

# Setup motors and sensors
left_motor.setPosition(float('inf'))
right_motor.setPosition(float('inf'))
left_motor.setVelocity(0.0)
right_motor.setVelocity(0.0)
left_sensor.enable(TIME_STEP)
right_sensor.enable(TIME_STEP)
lidar.enable(TIME_STEP)
lidar.enablePointCloud()
gyro = robot.getDevice("gyro")
gyro.enable(TIME_STEP)


# Initialize the robot using the REST API
ROBOT_NAME = robot.getName()
initialized, ROBOT_ID, pose, DEFAULT_POSITION, active = initiate_robot(ROBOT_NAME)

# Check if the robot was initialized successfully
if not initialized:
    print(f"Robot {ROBOT_NAME} not initialized. Exiting.")
    exit(1)

# Initialize maps
grid_map = np.zeros((MAP_SIZE_X, MAP_SIZE_Y), dtype=np.int8)
obstacle_map = np.zeros((MAP_SIZE_X, MAP_SIZE_Y), dtype=np.int16)
occupancy_map = np.zeros((MAP_SIZE_X, MAP_SIZE_Y), dtype=np.int8)

ROBOT_CORRIDORS_IDS = {"Robot 1": None, "Robot 2": None, "Robot 3": None}

# ──────────────────────────────────────────────────────────────
# SOCKETIO FOR ROBOT UPDATES
# ──────────────────────────────────────────────────────────────

# Threading event to signal when the map is received from another robot
map_received = False

# Function to handle map updates from other robots
# This function will be called when a map update is received
def handle_map_update(received_grid, received_obstacle, robot_id):
    global grid_map, obstacle_map, map_received
    print(f"[Controller] New map received from robot: {robot_id}.")

    grid_map = received_grid
    obstacle_map = received_obstacle

    map_received = True  # Set the flag to signal that the map has been received


def handle_corridor_update(data):
    global ROBOT_CORRIDORS_IDS
    print(f"[Controller] New corridor status received: {data}.")
    ROBOT_CORRIDORS_IDS = data

connect_to_server()
register_map_update_callback(handle_map_update)
corridor_update_callback(handle_corridor_update)

# ──────────────────────────────────────────────────────────────
# FUNCTIONS FOR CONCURRENCY
# ──────────────────────────────────────────────────────────────

# Function to send status updates and map images in the background
# Runs in a separate thread

# def task_callback_wrapper(ch, method, properties, body):
#     global task_queue, ready_to_accept_task, ready_to_accept_task_lock
#     on_task_received(ch, method, properties, body, task_queue, ready_to_accept_task, ready_to_accept_task_lock)

def background_logger(interval):
    global ROBOT_NAME, pose, path, frontiers, current_target, end_target, grid_map, obstacle_map, task_queue

    while True:
        try:
            # Sleep for the specified interval
            time.sleep(interval)
            status_update = create_status_update(ROBOT_NAME, pose, path, frontiers, current_target, end_target, ROBOT_ID)
            send_status_update(status_update)

            map_img = plot_map(path, frontiers, pose, grid_map, occupancy_map, ROBOT_NAME)
            send_map_update(map_img, ROBOT_NAME)

        except Exception as e:
            print(f"Error in background logger: {e}")

# Function generated by ChatGPT to batch tasks for concurrent processing
def batched(iterable, n):
    it = iter(iterable)
    while True:
        batch = list(islice(it, n))
        if not batch:
            break
        yield batch

# Function to find the paths to the frontiers using A* algorithm
# This function is called in a separate process to avoid blocking the main thread
def find_paths_to_frontiers(batch_args):
    robot_pos, frontier_list, grid_map_local = batch_args
    from SLAM.navigation import astar  # import for process

    results = []
    for frontier in frontier_list:
        path = astar(robot_pos, frontier, grid_map_local, occupancy_map, ROBOT_ID)
        if path:
            results.append((path, frontier))
    return results


# ──────────────────────────────────────────────────────────────
# MAIN LOOP
# ──────────────────────────────────────────────────────────────

# Initialize variables
init_map = True          # Flag to indicate if the map is being initialized 
exploring = True         # Flag to indicate if the robot is exploring  
frontiers = []           # List of frontiers to explore

current_target = None    # Target to drive to in WORLD coordinates
end_target = None        # Final goal in MAP coordinates
path = []                # Planned path (list of MAP coordinates)

prev_left = 0.0          # Previous left wheel sensor value -> for odometry
prev_right = 0.0         # Previous right wheel sensor value -> for odometry

# === Target position ===
task_queue = queue.Queue()

ready_to_accept_task = False
ready_to_accept_task_lock = threading.Lock()

MANUAL_POSITION = None  # Set to None for automatic exploration
# DEFAULT_POSITION = (5, 20)
PICK_INTERVAL = 300
pick_counter = 0

FRONTIERS_INTERVAL = 5  # Interval for finding frontiers
frontiers_counter = FRONTIERS_INTERVAL

in_corridor = False

# === NO EXPLORATION (comment or uncomment these two lines) ===
# grid_map = backup_map.copy()
# exploring = False

# Start thread for logging and visualization
logger_thread = threading.Thread(target=background_logger, daemon=True, args=(0.2,))
logger_thread.start()

# ____ Connect to task queue _____
# start_async_task_queue_listener(task_callback_wrapper)

# Main loop
while robot.step(TIME_STEP) != -1:
    # If the robot is not active, wait for a map to be received
    if not active:
        if map_received:
            exploring = False
            active = True
        else:
            continue

    if MANUAL_POSITION is None and ready_to_accept_task == False:
        with ready_to_accept_task_lock:
            ready_to_accept_task = True

    if MANUAL_POSITION is None and task_queue.qsize() > 0:
        print(task_queue.get())
        MANUAL_POSITION = task_queue.get()

    # print(f"manual pos : {MANUAL_POSITION}")
    # print(f"Task queue: {task_queue.qsize()}")


    # 1. Update the robot's pose using odometry and gyroscope
    pose, prev_left, prev_right = update_odometry(
        pose, prev_left, prev_right, left_sensor, right_sensor, gyro, alpha=0.0)

    robot_position = world_to_map(pose[0], pose[1])

    corridor_id = get_corridor_id(pose)
    if corridor_id:
        if not in_corridor:
            ROBOT_CORRIDORS_IDS[ROBOT_NAME] = corridor_id
            send_corridor_update(ROBOT_CORRIDORS_IDS)
            in_corridor = True
    elif in_corridor:
        ROBOT_CORRIDORS_IDS[ROBOT_NAME] = None
        send_corridor_update(ROBOT_CORRIDORS_IDS)
        in_corridor = False

    # 2. Update the map with lidar data
    grid_map, obstacle_map, occupancy_map = update_map(pose, lidar, grid_map, obstacle_map, occupancy_map, ROBOT_CORRIDORS_IDS, init_map)

    
    if init_map:
        init_map = False
    # 3. Determine current robot position

    # 4. Inflate obstacles
    grid_map = inflate_obstacles(grid_map, frontiers)

    # === HANDLE MANUAL POSITION FIRST ===
    if MANUAL_POSITION is not None and not path:
        trial = astar(robot_position, MANUAL_POSITION, grid_map, occupancy_map, ROBOT_ID)
        if trial:
            path = trial
            end_target = path[-1]
            current_target = map_to_world(path[0][0], path[0][1])

    # === EXPLORATION ===
    elif exploring:
        frontiers_counter += 1
        
        if frontiers_counter > FRONTIERS_INTERVAL:
            frontiers = find_frontier(grid_map)
            frontiers_counter = 0

        if not frontiers or robot.getTime() > 900:
            print("Stopping exploration — no frontiers found.")
            exploring = False
            current_target = None
            end_target = None
            path = []
            frontiers = []

            send_map_data(grid_map, obstacle_map, ROBOT_ID)
            continue

        if not path:
            results = []
            tasks = [(robot_position, batch, grid_map) for batch in batched(frontiers, 10)]

            results = []
            with concurrent.futures.ProcessPoolExecutor() as executor:
                batch_results = executor.map(find_paths_to_frontiers, tasks)
                for group in batch_results:
                    results.extend(group)  

            valid_paths = [(trial, frontier) for trial, frontier in results if trial]

            if valid_paths:
                best_path, best_frontier = min(valid_paths, key=lambda x: len(x[0]))
                path = best_path
                end_target = path[-1]
                current_target = map_to_world(path[0][0], path[0][1])
            else:
                print("Stopping exploration — no valid paths found.")
                exploring = False
                current_target = None
                end_target = None
                path = []
                frontiers = []

                send_map_data(grid_map, obstacle_map, ROBOT_ID)


    # === FOLLOW PATH ===
    if path:
        rerouting = False
        for cell in path:
            if grid_map[cell[0], cell[1]] == OBSTACLE:
                print("Rerouting — obstacle detected on path.")
                path = []
                end_target = None
                current_target = None
                rerouting = True
                break

        if rerouting:
            continue

        if math.hypot(pose[0] - current_target[0], pose[1] - current_target[1]) < 0.10:
            path.pop(0)
            if path:
                current_target = map_to_world(path[0][0], path[0][1])
            else:
                current_target = None

        if current_target:
            drive_to_target(current_target, pose, left_motor, right_motor)
        elif not current_target and MANUAL_POSITION is not None:
            # After reaching MANUAL_POSITION, pause, then go to DEFAULT_POSITION
            if pick_counter <= PICK_INTERVAL:
                left_motor.setVelocity(0.0)
                right_motor.setVelocity(0.0)
                pick_counter += 1
            else:
                trial = astar(robot_position, DEFAULT_POSITION, grid_map, occupancy_map, ROBOT_ID)
                if trial:
                    path = trial
                    end_target = path[-1]
                    current_target = map_to_world(path[0][0], path[0][1])
                MANUAL_POSITION = None
                pick_counter = 0
        else:
            print("No target — stopping.")
            path = []
            left_motor.setVelocity(0.0)
            right_motor.setVelocity(0.0)

    # === If no path (backup): return to start ===
    else:
        end_target = DEFAULT_POSITION
        path = astar(robot_position, end_target, grid_map, occupancy_map, ROBOT_ID)
        if path:
            current_target = map_to_world(path[0][0], path[0][1])

